require("babel-polyfill");
var _class = require("../build");
var QueryObj = require("neo4j-query-object");
var data = require("../private/passwords.json");

/*
 * This interacts with a real Neo4J database, it doesn't affect the database
 * but it does use it to bounce queries off back to the parser. You must have
 * a neo4j database running somewhere and be able to connect to its restful
 * interface. If your not interested in much of any setup, the class is already
 * preconfigured to connect with the defaults although in the case of quick setup
 * for the database you must connect to the web interface and set the first-time
 * password as required by Neo4J.
 *
 * This expects a folder called private to be created at the root project level.
 * In this folder a file called passwords.json needs to exist to contain the
 * username, password, and url under a "db" key. You can set the keys to all
 * undefined if you wish to use the class defaults.
 */

describe("class", function()
{
    beforeEach(function()
    {
        this.inst = new _class({
            username: data.db.username,
            password: data.db.password,
            url: data.db.url
        });
    });

    describe("constructor", function()
    {
        it("default", function()
        {
            var inst = new _class();
            expect(inst.username).toEqual("neo4j");
            expect(inst.password).toEqual("neo4j");
            expect(inst.url).toEqual("http://localhost:7474");
            expect(inst.raw).toEqual(false);
            expect(inst.transactionQueue).toEqual([]);
            expect(inst.queryQueue).toEqual({});
            expect(inst.transaction).toEqual([]);
        });

        it("all properties filled out", function()
        {
            var configObj = {
                username: data.db.username,
                password: data.db.password,
                url: data.db.url,
                raw: true,
                transactionQueue: [[
                    false,
                    new QueryObj({
                        query: 'return "Hello Transaction Queue"'
                    })
                ]],
                queryQueue: {
                    "default": [
                        new QueryObj({
                            query: 'return "Hello Query Queue"'
                        })
                    ]
                },
                transaction: [
                    new QueryObj({
                        query: 'return "Hello Transaction"'
                    })
                ]
            };

            var inst = new _class(configObj);

            expect(inst.username).toEqual(configObj.username);
            expect(inst.password).toEqual(configObj.password);
            expect(inst.url).toEqual(configObj.url);
            expect(inst.raw).toEqual(configObj.raw);
            expect(inst.transactionQueue).toEqual(configObj.transactionQueue);
            expect(inst.queryQueue).toEqual(configObj.queryQueue);
            expect(inst.transaction).toEqual(configObj.transaction);
        });

        it("invalid properties", function()
        {
            var inst = new _class({
                username: true,
                password: false,
                url: null,
                raw: "something",
                transactionQueue: null,
                queryQueue: "apples",
                transaction: {key: "value"}
            });

            expect(inst.username).toEqual("neo4j");
            expect(inst.password).toEqual("neo4j");
            expect(inst.url).toEqual("http://localhost:7474");
            expect(inst.raw).toEqual(false);
            expect(inst.transactionQueue).toEqual([]);
            expect(inst.queryQueue).toEqual({});
            expect(inst.transaction).toEqual([]);
        });
    });

    describe("update", function()
    {
        it("complete reset", function()
        {
            this.inst.update({}, true);

            expect(this.inst.username).toEqual("neo4j");
            expect(this.inst.password).toEqual("neo4j");
            expect(this.inst.url).toEqual("http://localhost:7474");
            expect(this.inst.raw).toEqual(false);
            expect(this.inst.transactionQueue).toEqual([]);
            expect(this.inst.queryQueue).toEqual({});
            expect(this.inst.transaction).toEqual([]);
        });

        it("arbitrary update", function()
        {
            this.inst.update({
                username: "newUsername"
            });

            expect(this.inst.username).toEqual("newUsername");
            expect(this.inst.password).toEqual(data.db.password);
            expect(this.inst.url).toEqual(data.db.url);
            expect(this.inst.raw).toEqual(false);
            expect(this.inst.transactionQueue).toEqual([]);
            expect(this.inst.queryQueue).toEqual({});
            expect(this.inst.transaction).toEqual([]);
        });
    });

    describe("addQuery", function()
    {
        it("defaults", function()
        {
            var ret = this.inst.addQuery();

            expect(ret).not.toBeDefined();
            expect(this.inst.queryQueue.default).toEqual(undefined);
        });

        it("all the very minimal variations", function()
        {
            var ret = this.inst.addQuery({
                query: 'return "Hello"'
            });

            if(typeof ret !== "object") fail("Expected Promise return");

            ret = this.inst.addQuery('return "Hello"');

            if(typeof ret !== "object") fail("Expected Promise return");

            ret = this.inst.addQuery(['return "Hello"']);

            if(typeof ret !== "object") fail("Expected Promise return");

            ret = this.inst.addQuery([{
                query: 'return "Hello"'
            }]);

            if(typeof ret !== "object") fail("Expected Promise return");

            expect(this.inst.queryQueue.default).toBeDefined();
            expect(this.inst.queryQueue.default.length).toEqual(4);
        });

        it("alternate queues", function()
        {
            this.inst.addQuery('return Hello', "queue1");
            this.inst.addQuery('return Hello2', "queue2");

            expect(this.inst.queryQueue.default).not.toBeDefined();
            expect(this.inst.queryQueue.queue1).toBeDefined();
            expect(this.inst.queryQueue.queue2).toBeDefined();

            expect(this.inst.queryQueue.queue1.length).toEqual(1);
            expect(this.inst.queryQueue.queue2.length).toEqual(1);
        });

        it("various multiple variations", function()
        {
            var ret = this.inst.addQuery([{
                query: 'return "Hello"'
            },
            'return "Hello"'
            ]);

            if(typeof ret !== "object") fail("Expected Promise return");

            ret = this.inst.addQuery(['return "Hello"','return "Hello"']);
            if(typeof ret !== "object") fail("Expected Promise return");
        });
    });

    it("reportErrors", function(done)
    {
        this.inst.transaction.push(new QueryObj({
            query: 'return "Hello"'
        }));

        this.inst.transaction[0].promise.then(function(resultObj)
        {
            fail("Error was suppose to occur");
        }).catch(function(resultObj)
        {
            expect(resultObj).toBeDefined();
            expect(resultObj.err).toEqual("Error");
            done();
        });

        this.inst.reportErrors("Error");
    });

    describe("execute", function()
    {
        it("defaults", function()
        {
            spyOn(this.inst, "nextInQueue");

            var ret = this.inst.execute();
            expect(ret).not.toBeDefined();
            expect(this.inst.nextInQueue.calls.count()).toEqual(0);
            expect(this.inst.transactionQueue.length).toEqual(0);
        });

        it("all the very minimal variations", function()
        {
            spyOn(this.inst, "nextInQueue");

            var ret = this.inst.execute({
                query: 'return "Hello"'
            });

            if(typeof ret !== "object") fail("Expected Promise return");
            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(2);
            expect(this.inst.transactionQueue[0][0]).toEqual(false);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));

            this.inst.transactionQueue = [];

            ret = this.inst.execute('return "Hello"');

            if(typeof ret !== "object") fail("Expected Promise return");
            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(2);
            expect(this.inst.transactionQueue[0][0]).toEqual(false);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));

            this.inst.transactionQueue = [];

            ret = this.inst.execute(['return "Hello"']);

            if(typeof ret !== "object") fail("Expected Promise return");
            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(2);
            expect(this.inst.transactionQueue[0][0]).toEqual(false);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));

            this.inst.transactionQueue = [];

            ret = this.inst.execute([{
                query: 'return "Hello"'
            }]);

            if(typeof ret !== "object") fail("Expected Promise return");
            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(2);
            expect(this.inst.transactionQueue[0][0]).toEqual(false);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));

            expect(this.inst.nextInQueue.calls.count()).toEqual(4);
        });

        it("various multiple variations", function()
        {
            spyOn(this.inst, "nextInQueue");

            var ret = this.inst.execute([{
                query: 'return "Hello"'
            },
            'return "Hello"'
            ]);

            if(typeof ret !== "object") fail("Expected Promise return");
            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(3);
            expect(this.inst.transactionQueue[0][0]).toEqual(false);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));
            expect(this.inst.transactionQueue[0][2]).toEqual(jasmine.any(QueryObj));

            this.inst.transactionQueue = [];

            ret = this.inst.execute(['return "Hello"','return "Hello"']);
            if(typeof ret !== "object") fail("Expected Promise return");

            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(3);
            expect(this.inst.transactionQueue[0][0]).toEqual(false);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));
            expect(this.inst.transactionQueue[0][2]).toEqual(jasmine.any(QueryObj));

            this.inst.transactionQueue = [];

            expect(this.inst.nextInQueue.calls.count()).toEqual(2);
        });

        it("raw mode", function()
        {
            spyOn(this.inst, "nextInQueue");

            var ret = this.inst.execute('return "Hello"', true);

            if(typeof ret !== "object") fail("Expected Promise return");
            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(2);
            expect(this.inst.transactionQueue[0][0]).toEqual(true);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));

            this.inst.transactionQueue = [];

            expect(this.inst.nextInQueue.calls.count()).toEqual(1);
        });
    });

    describe("commit", function()
    {
        it("defaults", function()
        {
            spyOn(this.inst, "nextInQueue");

            this.inst.queryQueue.default = [
                new QueryObj({query: 'return "Hello"'})
            ];

            this.inst.commit();

            expect(this.inst.queryQueue.default).toEqual([]);
            expect(this.inst.nextInQueue.calls.count()).toEqual(1);

            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(2);
            expect(this.inst.transactionQueue[0][0]).toEqual(false);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));
        });

        it("raw mode", function()
        {
            spyOn(this.inst, "nextInQueue");

            this.inst.queryQueue.default = [
                new QueryObj({query: 'return "Hello"'})
            ];

            this.inst.commit(true);

            expect(this.inst.queryQueue.default).toEqual([]);
            expect(this.inst.nextInQueue.calls.count()).toEqual(1);

            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(2);
            expect(this.inst.transactionQueue[0][0]).toEqual(true);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));
        });

        it("alternate queue", function()
        {
            spyOn(this.inst, "nextInQueue");

            this.inst.queryQueue.queue1234 = [
                new QueryObj({query: 'return "Hello"'})
            ];

            this.inst.commit(false, "queue1234");

            expect(this.inst.queryQueue.queue1234).toEqual([]);
            expect(this.inst.nextInQueue.calls.count()).toEqual(1);

            expect(this.inst.transactionQueue.length).toEqual(1);
            expect(this.inst.transactionQueue[0].length).toEqual(2);
            expect(this.inst.transactionQueue[0][0]).toEqual(false);
            expect(this.inst.transactionQueue[0][1]).toEqual(jasmine.any(QueryObj));
        });
    });

    describe("nextInQueue", function()
    {
        it("with transaction non-empty", function()
        {
            spyOn(this.inst, "send");

            this.inst.transaction = [
                new QueryObj({query: 'return "Hello"'})
            ];

            this.inst.nextInQueue();

            expect(this.inst.send.calls.count()).toEqual(0);
        });

        it("with transactionQueue empty", function()
        {
            spyOn(this.inst, "send");
            this.inst.nextInQueue();
            expect(this.inst.send.calls.count()).toEqual(0);
        });

        it("with 1 valid transaction queue item", function()
        {
            spyOn(this.inst, "send");

            var transactionQueue = [[
                false,
                new QueryObj({query: 'return "Hello"'})
            ]]

            this.inst.transactionQueue = [[
                transactionQueue[0][0],
                transactionQueue[0][1]
            ]];

            this.inst.nextInQueue();

            expect(this.inst.transactionQueue).toEqual([]);
            expect(this.inst.transaction).toEqual([transactionQueue[0][1]]);
            expect(this.inst.send.calls.count()).toEqual(1);
            expect(this.inst.send.calls.allArgs()).toEqual([[false]]);
        });

        it("with 2 valid transaction queue items", function()
        {
            spyOn(this.inst, "send");

            var transactionQueue = [[
                false,
                new QueryObj({query: 'return "Hello"'}),
                new QueryObj({query: 'return "Hello2"'})
            ]]

            this.inst.transactionQueue = [[
                transactionQueue[0][0],
                transactionQueue[0][1],
                transactionQueue[0][2]
            ]];

            this.inst.nextInQueue();

            expect(this.inst.transactionQueue).toEqual([]);
            expect(this.inst.transaction).toEqual([
                transactionQueue[0][1],
                transactionQueue[0][2]
            ]);
            expect(this.inst.send.calls.count()).toEqual(1);
            expect(this.inst.send.calls.allArgs()).toEqual([[false]]);
        });

        it("with 1 valid raw mode transaction queue item", function()
        {
            spyOn(this.inst, "send");

            var transactionQueue = [[
                true,
                new QueryObj({query: 'return "Hello"'})
            ]]

            this.inst.transactionQueue = [[
                transactionQueue[0][0],
                transactionQueue[0][1]
            ]];

            this.inst.nextInQueue();

            expect(this.inst.transactionQueue).toEqual([]);
            expect(this.inst.transaction).toEqual([
                transactionQueue[0][1]
            ]);
            expect(this.inst.send.calls.count()).toEqual(1);
            expect(this.inst.send.calls.allArgs()).toEqual([[true]]);
        });

        it("with 1 valid & 1 invalid transaction queue items", function()
        {
            spyOn(this.inst, "send");

            var transactionQueue = [[
                false,
                {query: 'return "Hello"'},
                new QueryObj({query: 'return "Hello2"'})
            ]]

            this.inst.transactionQueue = [[
                transactionQueue[0][0],
                transactionQueue[0][1],
                transactionQueue[0][2]
            ]];

            this.inst.nextInQueue();

            expect(this.inst.transactionQueue).toEqual([]);
            expect(this.inst.transaction).toEqual([
                transactionQueue[0][2]
            ]);
            expect(this.inst.send.calls.count()).toEqual(1);
            expect(this.inst.send.calls.allArgs()).toEqual([[false]]);
        });
    });

    describe("send", function()
    {
        it("send 1 non-error transaction", function(done)
        {
            var transaction = [
                new QueryObj({query: 'return "Hello"'})
            ];

            transaction[0].promise.then(function(resultObj)
            {
                expect(resultObj.firstValue).toEqual("Hello");
                expect(this.inst.transaction).toEqual([]);
                done();
            }.bind(this)).catch(function(resultObj)
            {
                fail("Promise not suppose to be rejected");
            });

            this.inst.transaction = [
                transaction[0]
            ];

            this.inst.send();
        });

        it("send 1 error transaction", function(done)
        {
            var transaction = [
                new QueryObj({query: 'return Hello'})
            ];

            transaction[0].promise.then(function(resultObj)
            {
                fail("Promise not suppose to be resolved");
            }).catch(function(resultObj)
            {
                expect(resultObj.err).toBeDefined();
                expect(this.inst.transaction).toEqual([]);
                done();
            }.bind(this));

            this.inst.transaction = [
                transaction[0]
            ];

            this.inst.send();
        });

        it("send 1 non-error global raw transaction of 2 queries", function(done)
        {
            var transaction = [
                new QueryObj({query: 'return "Hello"'}),
                new QueryObj({query: 'return "Hello2"'})
            ];

            // I give up, I admit defeat, Despite every single documentation I
            // could find online saying returning a promise in a then waits
            // until that promise is finsihed and then the next then uses that
            // promise. After 3 hours or more, I just smply gave up and was
            // unable to get that to happen at all. They either worked
            // individually or only the first would work. But returning the
            // second promise caused nothing to happen at all except for an
            // indefinite wait for it to be called despite the fact its already
            // been resolved.
            var bothPromises = Promise.all([
                transaction[0].promise,
                transaction[1].promise
            ]);

            var self = this;

            bothPromises
                .then(function(resultObjs)
                {
                    // This is messy, I dont liek it, but after 3+ hours I'm
                    // hungry, tired, and admitting defeat for now
                    expect(resultObjs.length).toEqual(2);
                    expect(resultObjs[0].firstValue).not.toEqual("Hello");
                    expect(resultObjs[1].firstValue).not.toEqual("Hello2");
                    expect(resultObjs[0].rawResult).toBeDefined();
                    expect(resultObjs[1].rawResult).toBeDefined();
                    expect(self.inst.transaction).toEqual([]);
                    done();
                })

                /*
                 * One day I'll get this much cleaner and better solutin to
                 * work for the secnd promise instead of messily working with
                 * an array above
                .then(function(resultObj)
                {
                    expect(resultObj.firstValue).not.toEqual("Hello2");
                    expect(resultObj.rawResult).toBeDefined();
                    expect(this.inst.transaction).toEqual([]);
                    done();
                }.bind(this))
                */

                .catch(function(resultObj)
                {
                    fail("Promise not suppose to be rejected");
                });

            this.inst.raw = true;

            this.inst.transaction = [
                transaction[0],
                transaction[1]
            ];

            this.inst.send();
        });

        it("send 1 non-error transaction-level raw transaction of 2 queries", function(done)
        {
            var transaction = [
                new QueryObj({query: 'return "Hello"'}),
                new QueryObj({query: 'return "Hello2"'})
            ];

            var bothPromises = Promise.all([
                transaction[0].promise,
                transaction[1].promise
            ]);

            var self = this;

            bothPromises
                .then(function(resultObjs)
                {
                    expect(resultObjs.length).toEqual(2);
                    expect(resultObjs[0].firstValue).not.toEqual("Hello");
                    expect(resultObjs[1].firstValue).not.toEqual("Hello2");
                    expect(resultObjs[0].rawResult).toBeDefined();
                    expect(resultObjs[1].rawResult).toBeDefined();
                    expect(self.inst.transaction).toEqual([]);
                    done();
                })

                .catch(function(resultObj)
                {
                    fail("Promise not suppose to be rejected");
                });

            this.inst.transaction = [
                transaction[0],
                transaction[1]
            ];

            this.inst.send(true);
        });

        it("send 1 non-error query-level raw transaction of 2 queries", function(done)
        {
            var transaction = [
                new QueryObj({query: 'return "Hello"', raw: true}),
                new QueryObj({query: 'return "Hello2"'})
            ];

            var bothPromises = Promise.all([
                transaction[0].promise,
                transaction[1].promise
            ]);

            var self = this;

            bothPromises
                .then(function(resultObjs)
                {
                    expect(resultObjs.length).toEqual(2);
                    expect(resultObjs[0].firstValue).not.toEqual("Hello");
                    expect(resultObjs[1].firstValue).toEqual("Hello2");
                    expect(self.inst.transaction).toEqual([]);
                    done();
                })

                .catch(function(resultObj)
                {
                    fail("Promise not suppose to be rejected");
                });

            this.inst.transaction = [
                transaction[0],
                transaction[1]
            ];

            this.inst.send();
        });
    });

    describe("Daily usage / interworking of class", function()
    {
        it("execute simple query", function(done)
        {
            this.inst.execute('return "Hello World"')
                .then(function(resultObj)
                {
                    expect(resultObj.firstValue).toEqual("Hello World");
                    done();
                })
                .catch(function(resultObj)
                {
                    fail("Not suppose to throw error");
                });
        });

        it("execute stacked queries and transactions", function(done)
        {
            this.inst.addQuery('return "Hello World Query"');
            this.inst.addQuery('return "Hello World Query"');
            this.inst.addQuery('return "Hello World Query2"', "queue2");
            this.inst.execute('return "Hello World"');
            this.inst.execute('return "Hello World"');
            this.inst.commit(false);
            this.inst.commit(false, "queue2");
            this.inst.execute('return "Hello World"')
                .then(function(resultObj)
                {
                    expect(resultObj.firstValue).toEqual("Hello World");
                    done();
                })
                .catch(function(resultObj)
                {
                    fail("Not suppose to throw error");
                });
        });
    });
});
